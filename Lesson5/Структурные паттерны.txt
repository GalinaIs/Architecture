1.	Отличным примером применения паттернов «Декоратор» является библиотека java.io языка Java. В библиотеке есть интерфейс InputStream (аналогично и OutputStream) и есть очень много классов – декораторов, которые меняют функциональность класса, при этом в конструкторе принимают класс, реализующий интерфейс InputStream и возвращают объект своего класса, также реализующий InputStream. Например, BufferedInputStream – принимает в конструкторе класс InputStream  и размер буфера и позволяет организовать буферизированное чтение из источника данных или GZipInputSream – позволяет работать со сжатыми источниками данных, при этом сами функции работы с источниками данных остаются неизменными – функция read() например, что позволяет писать универсальные методы, объявляя переменные типом InputStream.
2.	Отличным примером применения паттернов «Адаптер» также является библиотека java.io языка Java. В библиотеке есть интерфейс DataInput (аналогично и DataOutput) и есть классы – адаптеры, которые позволяют работать с потоками данных InputStream, при этом считывая данные в нужном нам формате (int, long, Object и тд), при этом считывая из источников данных потом байт с помощью InputStream.
3.	Пример применения паттерна «Компоновщик» - в интернет магазине есть товар, который продается штучно, но также есть коробки, которые используются при формировании заказов. Очень часто заказы состоят из нескольких коробок, неполных коробок или же одного товара. Если мы хотим посчитать цену коробки, то нам нужно перебрать все товары коробки. Тогда как если же мы введем интерфейс Product, который будет реализовывать и коробка, и товар, то станет возможно по вызову одной функции узнать стоимость всей коробки.
4.	Примером паттерна «Фасад» можно привести написание приложения для прослушивания видеоконференции. Клиент подключается к приложению и хочет видеть видео и слышать звук, а как именно поток данных передается по сети от источника, как он собирается в картинку, на какие кадры дробиться и т.д.  – это ему не интересно. Грубо говоря, для него происходит вызов метода run(), а как именно данные из видеоконференции попадают в его приложение остается за кадром.