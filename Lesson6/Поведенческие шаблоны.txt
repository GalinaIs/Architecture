1.	Шаблон стратегия можно было бы использовать в моем проекте по yii, чтобы через реализацию интерфейса определять нужные параметры для выборки, например, задач из БД. Определить интерфейс с одним методом, который бы возвращал необходимый список задач и определить конкретные реализации данного интерфейса, например, когда нужны все задачи или задачи, просроченные за текущий месяц и т.д. Тогда бы логика выборки была бы скрыта в самом классе, а в контроллере можно было бы работать с классами как объектами типа реализуемого интерфейса.
2.	На мой взгляд, применение шаблонных методов можно использовать в случае, если у нас есть интернет магазин, в котором могут закупаться как розничные покупали, так и оптовые. Тогда порядок расчета суммы заказа будет отличать для розницы и для опта, но сам порядок оформления заказа, наполнения корзины, доставки и т.д. останется одинаковым. Для реализации различного расчета общей суммы заказа для оптовых и розничный покупателей можно объявить как абстрактный метод в классе с последующей реализацией в конкретных классах - розничный и оптовых покупателей.
3.	Используя шаблон наблюдатель, на сайте можно реализовать оповещение покупателя о новинках, о поступлении определенной категории товара, о скидках и т.д. в зависимости от того, на какие события подписан покупатель. У нас будет класс наблюдатель, которому будет сообщаться о том, что событие произошло (например, в магазине началась распродажа), тогда этот наблюдатель будет выбирать из БД покупателей, которые подписаны на это событие и им будут отправляться письма на эл.почту или смс-оповещения.
4.	Не знаю насколько правильно, но если одним из примеров, часто рассматриваемых для случая паттерна «Команда» является ресторан – когда клиент(client) пришел в ресторан, сделал заказ официанту(invoker), официант отнес заказ на кухню, повара (receiver) приготовили этот заказ, а официант принес его клиенту – то этот случай очень сильно похож на обращение пользователя  к сайту – пользователь нажимает на ссылку, кнопку, обновляет страницу или т.д. – таким образом отправляя запрос на сервер(invoker), а сервер(receiver) принимает обрабатывает запрос пользователя и возвращает ему ответ.